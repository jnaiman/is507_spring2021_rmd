---
title: "Intro to Numerical Data, Continuing Intro to R"
include_overview: true
week: 2
readings:
 - This weeks topics cover remaining parts of OIS 1.1, 1.2, 1.3, 2.1; OIS 1.4 & 2.3 (we won't cover 2.3 yet, but will cover the concepts presented here later in the class so feel free to read it over now).
 - We will also cover ITR 1, 2, 5, 6, 7, 12 (ITR can be skimmed or read in depth depending on comfort level with coding)
questions:
 - How can we analyze numerical data?
 - TBD
objectives:
 - TBD
keypoints:
 - "TBD"
source: Rmd
<!--latex_engine: xelatex-->
---



```{r setup, include=FALSE}
require("knitr")
#require("pandoc")
source("../bin/chunk-options.R")
source("../bin/functions.R")
library(tinytex)
```
<!-- JPN: attribution formatting -->
<style type="text/css" rel="stylesheet">
* {.attribution{
     position:absolute;
     bottom:0;
     right:0;
     font-size:0.5em
 }}
</style>

## Summary statistics and histograms with data in R

### Review

Last time we talked about some *summary statistics* and how to calculate them for data that is made up of numbers:
  * the *mean* is the sum of all data values divided by the number of data points
  * the *median* can be thought of as the "middle" number that splits the data into two halves if we order numerical data from smallest to largest
  * the *standard* deviaion is the square root of something called the *varience* which is roughly the average distnace of data values from the mean
  * the *first/third quartiles* delinate where 25% of the data falls below (first) and above (third) if we ordered the data from smallest to largest (the *median* is like the 50% or second quartile)

Let's do some analysis with "fake" class data showing programming histories of students in the class.

```{r d1p2}
classData = read.csv("data/formatted_class_answers.csv", stringsAsFactors=T)
# note: this is a placeholder for real data
```

Make sure this file is stored somewhere you can remember!  You can put it in the same directory as this file (or whatever R-script you are working from) or you can specify a location.  For example, on my Mac I can specify the default `Downloads` folder as the location with:

~~~
classData = read.csv("~/Downloads/formatted_class_answers.csv", stringsAsFactors=T)
~~~
{: .language-r}

What is in this dataset?

```{r d2p2}
classData
```

What are the names of the columns?
```{r cnp2}
colnames(classData)
```

Let's make a vector of the different languages folks use:
```{r lp2}
languages = classData[,3]
languages
```

We can also ask for the "levels" of these catagories:
```{r l2p2}
print(levels(languages))
```

Let's try making some plots of the language data.
```{r l3p3}
hist(languages) # should produce an error since "languages" is NOT a count - its a bunch of strings
```

Since `languages` is not numerical data, to make a histogram we have to play some tricks.  First, let's start by checking out the output of the `table` function:
```{r l4p3}
table(languages) # shows how many "hits" for a specific language
```

We can try using the `hist` function again:
```{r l4p2}
hist(table(languages)) # plots something now, but is actually counting # of bottom level, not counts
```

Not quite what we want, so let's try another plotting function called `barplot`:
```{r lh1p2}
barplot(table(languages)) # which sort of does what we want
```

Note: there are some long strings that aren't showing we can try changing one - for example, "python" should be "Python":
```{r lh2p2}
print(levels(languages))
```

We can fix this issue with some clever renaming of our levels:
```{r lh3p2}
print(levels(languages)[4]) # let's replace this
```
```{r lh4p2}
levels(languages)[4] = "Python" # with this
```

Take a look:
```{r lh5p2}
levels(languages)
```

Let's try replotting:
```{r lh6p2}
barplot(table(languages))
```

But what is the y axis?
```{r lh7p2}
barplot(table(languages),ylab='Counts')
```

<!-- JPN: note you need double dollar signs for latex here -->
Ok, but for many languages this can be hard to see $$\rightarrow$$ maybe different colors for each?
```{r lh8p2}
barplot(table(languages),ylab='Counts',col=c("red","blue","green","yellow","magenta"))
```

Ok cool, we see that a lot of folks use Python.

We can do the same sort of thing for the length of time folks have been coding:

```{r lh9p2}
time_in = classData[,4]
barplot(table(time_in)) 
```
Note: In RStudio, you'll have to expand the window to see all the labels.

Ok, so this tells us *something* but its hard to get a sense of the actual timescales since they are not ordered & are non-uniform increments of time.

Additionally, things are "out of order" because they don't fall in nice ordered time bins.  This is because this data is stored as "categorical" data, i.e. in this case as strings:
```{r ll1p2}
levels(time_in)
```

## Practicing for-loops and if-else statements

Let's reformat this data a bit and get some practice with for-loops in R in the process!

```{r f1p2}
time_min = c() # storage, save the min edge of our bins in years
time_max = c() # storage, save the max edge of our bins in years
```

Let's look at the options again:
```{r f2p2}
myLevels = levels(time_in)
print(myLevels)
```

Now we get to practice doing a for-loop in R.  Note, it is similar to how it's done in Python, but there are a few differences!  The syntax is generally:

~~~
for (loop_index in 1:Number_of_loops){
   # DO STUFF
}
~~~
{: .language-r}

Note that this definition includes `{}` instead of indentations to denote what is contained in the for-loop.  (if-statements are denoted similary as we'll see below.)

Let's do a for loop and determine bins by hand:
```{r f3p2}
for (i in 1:length(time_in)){
  if (time_in[i] == "< 6 months"){ # < 6 months
    time_min = c(time_min,0)
    time_max = c(time_max, 0.5) # in years => 0.5 years = 6 months
  } else if (time_in[i] == "Between 6 months to 1 year") { # 0.5-1 years
    time_min = c(time_min, 0.5)
    time_max = c(time_max, 1.0)
  } else if (time_in[i] == "1-2 years") { # 1-2 years
    time_min = c(time_min, 1.0)
    time_max = c(time_max, 2.0)
  } else if (time_in[i] == "2-4 years") { # 2-4 years
    time_min = c(time_min, 2.0)
    time_max = c(time_max, 4.0)
  } else { # otherwise, >4 years
    time_min = c(time_min,4.0) 
    time_max = c(time_max,5.0) # just giving an arbitrary upper bound of 5 years
  }
}
```

```{r f4p2}
print(time_min)
print(time_max)
```

Let's say the mid-point of this data is the `time`:
```{r f5p2}
time = 0.5*(time_min+time_max)
hist(time)
```

Note of course, in reality, the bins are not the same size so we can manually change the break-points to more accurately represent the data:
```{r f6p2}
hist(time,breaks=c(0.0,0.5,1,2,4,5))
```

Hmmm, but that looks like density, not counts, how do we get counts?
~~~
help(hist)
~~~
{: .language-r}
> ```{r lhelp22, echo = FALSE, results = "asis"}
> tmp <- tempfile()
> static_help("graphics", "hist", tmp)
> out <- readLines(tmp)
> headfoot <- grep("body>", out)
> cat(out[(headfoot[1] + 1):(headfoot[2] - 1)], sep = "\n")
> ```

See there is a "freq" variable, set to `TRUE` to get counts:
```{r f7p2}
hist(time,breaks=c(0.0,0.5,1,2,4,5),freq=TRUE)
```

We get an error telling us that the areas are wrong, but we have to think about what that means for us $$\rightarrow$$ do we actually care?  Density is telling us the frequency over the unit time, but thats not what we really want $$\rightarrow$$ we want counts with bars representing actual times.

Picking which one depends on your data & how you want to present it and you have to make sure to think about it.

## Summary statistics for class data

Let's look at some summary stats for our data for how long folks have been programming:
```{r f8p2}
summary(time)
```

